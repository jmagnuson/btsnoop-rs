use crate::{ControlCommand, ControlPacket};
use anyhow::anyhow;
use log::debug;
use nom_derive::Parse;
use std::{
    fs::File,
    io::{Read, Write},
    path::{Path, PathBuf}, sync::mpsc, thread::JoinHandle,
};

pub mod util;
use util::ReadExt as _;

pub struct ExtcapControlReader {
    pub in_file: File,
}

impl ExtcapControlReader {
    /// Creates a new instance of [`ExtcapControlReader`].
    pub fn new(in_path: &Path) -> Self {
        Self {
            in_file: File::open(in_path).unwrap(),
        }
    }

    pub fn read_control_packet(&self) -> Result<ControlPacket<'static>, anyhow::Error> {
        let mut in_file = &self.in_file;
        let header_bytes = in_file
            .try_read_exact::<6>()?
            .ok_or_else(|| std::io::Error::from(std::io::ErrorKind::UnexpectedEof))?;
        debug!(
            "Read header bytes from incoming control message, now parsing... {:?}",
            header_bytes
        );
        let (_rem, packet) = match ControlPacket::parse(&header_bytes) {
            Ok((rem, packet)) => (rem, packet.into_owned()),
            Err(nom::Err::Incomplete(nom::Needed::Size(size))) => {
                let mut payload_bytes = vec![0_u8; size.get()];
                in_file.read_exact(&mut payload_bytes)?;
                let all_bytes = [header_bytes.as_slice(), payload_bytes.as_slice()].concat();
                ControlPacket::parse(&all_bytes)
                    .map(|(_, packet)| (&[][..], packet.into_owned()))
                    .unwrap_or_else(|e| panic!("Unable to parse header packet: {e}"))
            }
            Err(e) => Err(anyhow!("Error parsing control packet: {e}"))?,
        };
        debug!("Parsed incoming control message: {packet:?}");
        Ok(packet)
    }
}

pub struct ThreadedExtcapControlReader {
    pub join_handle: JoinHandle<()>,
    pub read_channel: mpsc::Receiver<ControlPacket<'static>>,
}

impl ThreadedExtcapControlReader {
    pub fn spawn(in_path: PathBuf) -> Self {
        let (tx, rx) = mpsc::sync_channel::<ControlPacket<'static>>(1);
        let join_handle = std::thread::spawn(move || {
            let reader = ExtcapControlReader::new(&in_path);
            loop {
                tx.send(reader.read_control_packet().unwrap()).unwrap();
            }
        });
        Self {
            join_handle,
            read_channel: rx,
        }
    }

    pub fn try_read_packet(&self) -> Option<ControlPacket<'static>> {
        self.read_channel.try_recv().ok()
    }

    pub fn read_packet(&self) -> ControlPacket<'static> {
        self.read_channel.recv().unwrap()
    }
}

/// Manager for the extcap control pipes. The control pipes are a pair of FIFOs, one incoming and
/// one outgoing, and used to control extra functionalities, mostly UI-related, with Wireshark.
///
/// This class manages the serialization and deserialization of the control packets, and dispatches
/// them onto channels, so that functions running on other tasks can subcribe to and emit
/// those control packets.
///
/// See <https://www.wireshark.org/docs/wsdg_html_chunked/ChCaptureExtcap.html> for details.
pub struct ExtcapControlSender {
    out_file: File,
}

impl ExtcapControlSender {
    /// Creates a new instance of [`ExtcapControlSender`].
    pub fn new(out_path: &Path) -> Self {
        Self {
            out_file: File::create(out_path).unwrap(),
        }
    }
}

impl ExtcapControlSenderTrait for ExtcapControlSender {
    fn send(&mut self, packet: ControlPacket<'_>) {
        self.out_file.write_all(&packet.to_header_bytes()).unwrap();
        self.out_file.write_all(&packet.payload).unwrap();
        self.out_file.flush().unwrap();
    }
}

/// Sender for extcap control packets. These control packets controls the UI generated by Wireshark.
/// See <https://www.wireshark.org/docs/wsdg_html_chunked/ChCaptureExtcap.html> for details.
pub trait ExtcapControlSenderTrait {
    const UNUSED_CONTROL_NUMBER: u8 = 255;

    fn send(&mut self, packet: ControlPacket<'_>);

    /// Enable a button with the given control number.
    fn enable_button(&mut self, button: u8) {
        self.send(ControlPacket::new(button, ControlCommand::Enable, &[]))
    }

    /// Disable a button with the given control number.
    fn disable_button(&mut self, button: u8) {
        self.send(ControlPacket::new(button, ControlCommand::Disable, &[]))
    }

    /// Shows a message in an information dialog popup.
    fn info_message(&mut self, message: &str) {
        self.send(ControlPacket::new(
            Self::UNUSED_CONTROL_NUMBER,
            ControlCommand::InformationMessage,
            message.as_bytes(),
        ))
    }

    /// Shows a message in a warning dialog popup.
    fn warning_message(&mut self, message: &str) {
        self.send(ControlPacket::new(
            Self::UNUSED_CONTROL_NUMBER,
            ControlCommand::WarningMessage,
            message.as_bytes(),
        ))
    }

    /// Shows a message in an error dialog popup.
    fn error_message(&mut self, message: &str) {
        self.send(ControlPacket::new(
            Self::UNUSED_CONTROL_NUMBER,
            ControlCommand::ErrorMessage,
            message.as_bytes(),
        ))
    }

    /// Shows a message in the status bar
    fn status_message(&mut self, message: &str) {
        self.send(ControlPacket::new(
            Self::UNUSED_CONTROL_NUMBER,
            ControlCommand::StatusbarMessage,
            message.as_bytes(),
        ))
    }

    /// Run the "set" operation
    // TODO: Break this down to type-specific functions like Log.add()
    fn set_value(&mut self, control: u8, value: &str) {
        self.set_value_bytes(control, value.as_bytes())
    }

    fn set_value_bytes(&mut self, control: u8, value: &[u8]) {
        self.send(ControlPacket::new(control, ControlCommand::Set, value))
    }

    fn add_value(&mut self, control: u8, value: &str) {
        self.send(ControlPacket::new(
            control,
            ControlCommand::Add,
            value.as_bytes(),
        ))
    }

    fn remove_value(&mut self, control: u8, value: &str) {
        self.send(ControlPacket::new(
            control,
            ControlCommand::Remove,
            value.as_bytes(),
        ))
    }
}
